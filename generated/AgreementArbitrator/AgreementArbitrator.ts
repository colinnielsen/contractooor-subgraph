// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AgreementInitiated extends ethereum.Event {
  get params(): AgreementInitiated__Params {
    return new AgreementInitiated__Params(this);
  }
}

export class AgreementInitiated__Params {
  _event: AgreementInitiated;

  constructor(event: AgreementInitiated) {
    this._event = event;
  }

  get agreementNonce(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get provider(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get client(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get contractooorAgreement(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get streamId(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class AgreementProposed extends ethereum.Event {
  get params(): AgreementProposed__Params {
    return new AgreementProposed__Params(this);
  }
}

export class AgreementProposed__Params {
  _event: AgreementProposed;

  constructor(event: AgreementProposed) {
    this._event = event;
  }

  get agreementHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get agreementNonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get proposer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get provider(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get client(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get contractURI(): string {
    return this._event.parameters[5].value.toString();
  }

  get targetEndTimestamp(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get streamToken(): Address {
    return this._event.parameters[7].value.toAddress();
  }

  get totalStreamedTokens(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get terminationClauses(): AgreementProposedTerminationClausesStruct {
    return changetype<AgreementProposedTerminationClausesStruct>(
      this._event.parameters[9].value.toTuple()
    );
  }
}

export class AgreementProposedTerminationClausesStruct extends ethereum.Tuple {
  get atWillDays(): i32 {
    return this[0].toI32();
  }

  get cureTimeDays(): i32 {
    return this[1].toI32();
  }

  get legalCompulsion(): boolean {
    return this[2].toBoolean();
  }

  get moralTurpitude(): boolean {
    return this[3].toBoolean();
  }

  get bankruptcyDissolutionInsolvency(): boolean {
    return this[4].toBoolean();
  }

  get counterpartyMalfeasance(): boolean {
    return this[5].toBoolean();
  }

  get lostControlOfPrivateKeys(): boolean {
    return this[6].toBoolean();
  }
}

export class AgreementArbitrator__getAgreementHashInputTerminationClausesStruct extends ethereum.Tuple {
  get atWillDays(): i32 {
    return this[0].toI32();
  }

  get cureTimeDays(): i32 {
    return this[1].toI32();
  }

  get legalCompulsion(): boolean {
    return this[2].toBoolean();
  }

  get moralTurpitude(): boolean {
    return this[3].toBoolean();
  }

  get bankruptcyDissolutionInsolvency(): boolean {
    return this[4].toBoolean();
  }

  get counterpartyMalfeasance(): boolean {
    return this[5].toBoolean();
  }

  get lostControlOfPrivateKeys(): boolean {
    return this[6].toBoolean();
  }
}

export class AgreementArbitrator extends ethereum.SmartContract {
  static bind(address: Address): AgreementArbitrator {
    return new AgreementArbitrator("AgreementArbitrator", address);
  }

  getAgreementHash(
    signingParty: Address,
    agreementNonce: BigInt,
    provider: Address,
    client: Address,
    contractURI: string,
    termLength: BigInt,
    streamToken: Address,
    totalStreamedTokens: BigInt,
    terminationClauses: AgreementArbitrator__getAgreementHashInputTerminationClausesStruct
  ): Bytes {
    let result = super.call(
      "getAgreementHash",
      "getAgreementHash(address,uint256,address,address,string,uint32,address,uint256,(uint16,uint16,bool,bool,bool,bool,bool)):(bytes32)",
      [
        ethereum.Value.fromAddress(signingParty),
        ethereum.Value.fromUnsignedBigInt(agreementNonce),
        ethereum.Value.fromAddress(provider),
        ethereum.Value.fromAddress(client),
        ethereum.Value.fromString(contractURI),
        ethereum.Value.fromUnsignedBigInt(termLength),
        ethereum.Value.fromAddress(streamToken),
        ethereum.Value.fromUnsignedBigInt(totalStreamedTokens),
        ethereum.Value.fromTuple(terminationClauses)
      ]
    );

    return result[0].toBytes();
  }

  try_getAgreementHash(
    signingParty: Address,
    agreementNonce: BigInt,
    provider: Address,
    client: Address,
    contractURI: string,
    termLength: BigInt,
    streamToken: Address,
    totalStreamedTokens: BigInt,
    terminationClauses: AgreementArbitrator__getAgreementHashInputTerminationClausesStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getAgreementHash",
      "getAgreementHash(address,uint256,address,address,string,uint32,address,uint256,(uint16,uint16,bool,bool,bool,bool,bool)):(bytes32)",
      [
        ethereum.Value.fromAddress(signingParty),
        ethereum.Value.fromUnsignedBigInt(agreementNonce),
        ethereum.Value.fromAddress(provider),
        ethereum.Value.fromAddress(client),
        ethereum.Value.fromString(contractURI),
        ethereum.Value.fromUnsignedBigInt(termLength),
        ethereum.Value.fromAddress(streamToken),
        ethereum.Value.fromUnsignedBigInt(totalStreamedTokens),
        ethereum.Value.fromTuple(terminationClauses)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  sablier(): Address {
    let result = super.call("sablier", "sablier():(address)", []);

    return result[0].toAddress();
  }

  try_sablier(): ethereum.CallResult<Address> {
    let result = super.tryCall("sablier", "sablier():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _sablier(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _agreementSingleton(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AgreeToCall extends ethereum.Call {
  get inputs(): AgreeToCall__Inputs {
    return new AgreeToCall__Inputs(this);
  }

  get outputs(): AgreeToCall__Outputs {
    return new AgreeToCall__Outputs(this);
  }
}

export class AgreeToCall__Inputs {
  _call: AgreeToCall;

  constructor(call: AgreeToCall) {
    this._call = call;
  }

  get agreementNonce(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get provider(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get client(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get contractURI(): string {
    return this._call.inputValues[3].value.toString();
  }

  get termLength(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get streamToken(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get totalStreamedTokens(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get terminationClauses(): AgreeToCallTerminationClausesStruct {
    return changetype<AgreeToCallTerminationClausesStruct>(
      this._call.inputValues[7].value.toTuple()
    );
  }
}

export class AgreeToCall__Outputs {
  _call: AgreeToCall;

  constructor(call: AgreeToCall) {
    this._call = call;
  }
}

export class AgreeToCallTerminationClausesStruct extends ethereum.Tuple {
  get atWillDays(): i32 {
    return this[0].toI32();
  }

  get cureTimeDays(): i32 {
    return this[1].toI32();
  }

  get legalCompulsion(): boolean {
    return this[2].toBoolean();
  }

  get moralTurpitude(): boolean {
    return this[3].toBoolean();
  }

  get bankruptcyDissolutionInsolvency(): boolean {
    return this[4].toBoolean();
  }

  get counterpartyMalfeasance(): boolean {
    return this[5].toBoolean();
  }

  get lostControlOfPrivateKeys(): boolean {
    return this[6].toBoolean();
  }
}
